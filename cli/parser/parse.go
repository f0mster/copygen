// Package parser parses a setup file's functions, types, and fields using an Abstract Syntax Tree.
package parser

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"path/filepath"

	"github.com/switchupcb/copygen/cli/models"
	"github.com/switchupcb/copygen/cli/parser/options"
	"golang.org/x/tools/go/packages"
)

var (
	// convertOptions represents a global list of convert options (for convert functions).
	convertOptions []*options.Option

	// aliasImportMap represents a global map of package paths to aliased import variables names (defined in the setup file).
	aliasImportMap map[string]string

	// ignorepkgpath is used to prevent the field parser from assigning a package name
	// to a field that is defined in the setup file's package.
	ignorepkgpath string
)

// Parser represents a parser that parses Abstract Syntax Tree data into models.
type Parser struct {
	// CommentOptionMap represents a map of function (field-specific) options to comments.
	CommentOptionMap CommentOptionMap
	Config           Config
	Pkgs             []*packages.Package
}

// Config represents a Parser's configuration.
type Config struct {
	// SetupFile represents the setup file as an Abstract Syntax Tree.
	SetupFile *ast.File

	// Fileset represents the parser's fileset.
	Fileset *token.FileSet

	// Setpath represents the setup filepath.
	Setpath string
}

// parserLoadMode represents the load mode required for sufficient information during package load.
const parserLoadMode = packages.NeedName + packages.NeedImports + packages.NeedDeps + packages.NeedTypes + packages.NeedSyntax + packages.NeedTypesInfo

// Parse parses a generator's setup file.
func Parse(gen *models.Generator) error {
	p, err := setupParser(gen)
	if err != nil {
		return fmt.Errorf("%w", err)
	}

	// Write the Keep.
	removed, err := Keep(p.Config.SetupFile)
	if err != nil {
		return fmt.Errorf("%w", err)
	}

	if removed.Copygen == nil {
		return fmt.Errorf("the \"type Copygen interface\" could not be found in the setup file")
	}

	buf := new(bytes.Buffer)
	buf.WriteString("// Code generated by github.com/switchupcb/copygen\n// DO NOT EDIT.\n\n")
	if err := printer.Fprint(buf, p.Config.Fileset, p.Config.SetupFile); err != nil {
		return fmt.Errorf("an error occurred writing the code that will be kept after generation\n%w", err)
	}

	gen.Keep = buf.Bytes()

	// Parse ast.Comments into Options.
	convertOptions = removed.ConvertOptions
	p.CommentOptionMap, err = MapCommentsToOptions(removed.Comments)
	if err != nil {
		return fmt.Errorf("an error occurred while parsing comments for options\n%w", err)
	}

	// Set up an import map for aliased import variable names.
	aliasImportMap = make(map[string]string, len(p.Config.SetupFile.Imports))
	for _, imp := range p.Config.SetupFile.Imports {
		if imp.Name != nil {
			aliasImportMap[imp.Path.Value[1:len(imp.Path.Value)-1]] = imp.Name.Name
		}
	}

	// Analyze the `type Copygen Interface` to create models.Function and models.Field objects.
	// load package types from the setup file (NOTE: loads a different *ast(s)).
	cfg := &packages.Config{Mode: parserLoadMode}
	p.Pkgs, err = packages.Load(cfg, "file="+p.Config.Setpath)
	if err != nil {
		return fmt.Errorf("an error occurred while loading the packages for types.\n%w", err)
	}
	ignorepkgpath = p.Pkgs[0].PkgPath

	// create the models.Function objects.
	if gen.Functions, err = p.parseFunctions(removed.Copygen); err != nil {
		return fmt.Errorf("%w", err)
	}

	return nil
}

func setupParser(gen *models.Generator) (*Parser, error) {
	// determine the actual filepath of the setup.go file.
	absfilepath, err := filepath.Abs(filepath.Join(filepath.Dir(gen.Loadpath), gen.Setpath))
	if err != nil {
		return nil, fmt.Errorf("%w", err)
	}

	// Setup the parser.
	p := &Parser{
		Config: Config{
			Setpath: absfilepath,
		},
	}
	p.Config.Fileset = token.NewFileSet()
	p.Config.SetupFile, err = parser.ParseFile(p.Config.Fileset, absfilepath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("an error occurred parsing the specified .go setup file: %v\n%w", gen.Setpath, err)
	}
	return p, nil
}
